## 副作用函数

执行后会直接或间接影响其他函数的方法。

```javaScript
const obj={text:'hello world'}
function effect() {
    document.body.innerText=obj.text
}
effect()
```

## 响应式数据的实现

vue2响应式数据是基于Object.defineProperty，vue3响应式数据是基于[[es6#proxy|proxy]]，当`obj.text`变化后，副作用函数自动执行，那么这个对象`obj`就是==响应式数据==

### 响应式数据的基本实现

- 执行副作用函数`effect`时，触发字段`obj.text`的**读取**操作
- 修改`obj.text`的值时，触发其**设置**操作

通过拦截对象的读取和设置，使其在设置时执行副作用函数

![[Drawing 2022-11-17 10.52.03.excalidraw.svg]]
``` html
<html>
<body></body>
<script>
    // 存储副作用函数
    const bucket = new Set()
    // 原始数据
    const data = { text: 'data' }
    // 原始数据的代理
    const obj = new Proxy(data, {
        get: function (target, attr) {
            // 变量里面暂存数据更新操作
            bucket.add(effect)
            return target[attr];
        },
        set: function (target, key, newVal) {
            target[key] = newVal
            // 更新界面上的数据
            bucket.forEach(fn => fn());
            return true
        },
    });
    //测试
    function effect() {
        document.body.innerText = obj.text
    }
    //触发读取
    effect()
    //1秒后修改数据
    setTimeout(() => {
        obj.text = 'hello'
    }, 1000)
</script>
</html>
```

### 响应系统优化
#### 可以自定义副作用函数

修改了原先的硬编码的副作用函数，在函数名称不为effect依旧可以正确工作。

- 定义全局变量`activeEffect`存储被注册的副作用函数
- 重新定义effect函数来注册副作用函数
```html
<html>
<body></body>
<script>
    const bucket = new Set()
    const data = { text: 'data' }
    //存储被注册的副作用函数
    let activeEffect
    //注册副作用函数
    function effect(fn) {
        activeEffect = fn
        fn()
    }
    const obj = new Proxy(data, {
        get: function (target, attr) {
            //将activeEffect中储存的副作用函数收集到“桶”中
            if (activeEffect) {
                bucket.add(activeEffect)
            }
            //bucket.add(effect)
            return target[attr];
        },
        set: function (target, key, newVal) {
            target[key] = newVal
            bucket.forEach(fn => fn());
            return true
        },
    });
    //测试
    // function effect() {
    //     document.body.innerText = obj.text
    // }
    //触发读取
    effect(() => {
        document.body.innerText = obj.text
    })
    setTimeout(() => {
        obj.text = 'hello'
    }, 1000)

</script>
</html>
```


2.在字段未与副作用函数建立响应联系时，不执行副作用函数。----[[响应系统#使用WeakMap存储副作用函数的原因|重新设计存储副作用函数的数据结构]]

```html
<html>
<body></body>
<script>
    let activeEffect
    function effect(fn) {
        activeEffect = fn
        fn()
    }
    const bucket = new WeakMap()
    const data = { text: 'hi' }
    const obj = new Proxy(data, {
        get(target, key) {
            track(target, key)
            return target[key]
        },
        set(target, key, newVal) {
            target[key] = newVal
            trigger(target, key)
        }
    })
    function track(target, key) {
        if (!activeEffect) return
        let depsMap = bucket.get(target)
        if (!depsMap) {
            bucket.set(target, (depsMap = new Map()))
        }
        let deps = depsMap.get(key)
        if (!deps) {
            depsMap.set(key, (deps = new Set()))
        }
        deps.add(activeEffect)
    }
    function trigger(target, key) {
        const depsMap = bucket.get(target)
        if (!depsMap) return
        const effects = depsMap.get(key)
        effects && effects.forEach(fn => fn());
    }
    effect(() => { document.body.innerText = obj.text })
    setTimeout(() => {
        obj.text = 'hello'
    }, 1000)
</script>
</html>
```

## 使用WeakMap存储副作用函数的原因

![[es6#^354e2c]]

例如上面的场景中，如果target对象没有任何引用了，说明用户侧不再需要它了，这时垃圾回收器会完成回收任务。但如果使用Map来代替WeakMap，那么即使用户侧的代码对target没有任何引用，这个target也不会被回收，最终可能导致内存溢出。

![图 1 WeakMap、Map和Set之间的关系](WeakMap、Map和Set之间的关系.svg)

# 分支切换与cleanup

```html
<html>
<body></body>
<script>
    let activeEffect
    function effect(fn) {
        const effectFn = () => {
            cleanup(effectFn)
            activeEffect = fn
            fn()
        }
        effectFn.deps = []
        effectFn()
    }
    const bucket = new WeakMap()
    const data = { ok: true, text: 'hi' }
    const obj = new Proxy(data, {
        get(target, key) {
            track(target, key)
            return target[key]
        },
        set(target, key, newVal) {
            target[key] = newVal
            trigger(target, key)
        }
    })
    function track(target, key) {
        if (!activeEffect) return
        let depsMap = bucket.get(target)
        if (!depsMap) {
            bucket.set(target, (depsMap = new Map()))
        }
        let deps = depsMap.get(key)
        if (!deps) {
            depsMap.set(key, (deps = new Set()))
        }
        const test = new Set()
        deps.add(activeEffect)
    }
    function trigger(target, key) {
        const depsMap = bucket.get(target)
        if (!depsMap) return
        const effects = depsMap.get(key)
        const effectsToRun = new Set(effects)//add
        effectsToRun.forEach(effectFn => effectFn())//add
        //effects && effects.forEach(fn => fn());
    }
    function cleanup(effectFn) {
        for (let i = 0; i < effectFn.deps.length; i++) {
            const deps = effectFn.deps[i]
            deps.delete(effectFn)
        }
        effectFn.deps.length = 0
    }
    effect(() => { document.body.innerText = obj.ok ? obj.text : "NOT" })
    setTimeout(() => {
        obj.text = 'hello'
    }, 1000)
    setTimeout(() => {
        obj.ok = false
    }, 2000)
</script>
</html>
```