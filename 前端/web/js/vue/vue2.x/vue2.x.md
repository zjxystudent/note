通过js的object.defineProperty()数据劫持,实现响应式，

v-model是标签外value的zi双向绑定，v-bind是标签内属性的单向绑定，同时都支持数据的动态变化。

# 单向数据流

所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。

# 过滤器 filter

过滤器可以用在两个地方：双花括号插值和 v-bind 表达式
> vue3 中被删去

# 混合 mixin

vue2.x使用的是选项式API，混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。

## Mixin和Vuex的区别？
上面一点说Mixin就是一个抽离公共部分的作用。在Vue中，Vuex状态管理似乎也是做的这一件事，它也是将组件之间可能共享的数据抽离出来。两者看似一样，实则还是有细微的区别，区别如下：

- Vuex公共状态管理，如果在一个组件中更改了Vuex中的某个数据，那么其它所有引用了Vuex中该数据的组件也会跟着变化。

- Mixin中的数据和方法都是独立的，组件之间使用后是互相不影响的。

## 短板

1. 不清晰的数据来源：当使用了多个 mixin 时，实例上的数据属性来自哪个 mixin 变得不清晰，这使追溯实现和理解组件行为变得困难。这也是我们推荐在组合式函数中使用 ref + 解构模式的理由：让属性的来源在消费组件时一目了然。

2. 命名空间冲突：多个来自不同作者的 mixin 可能会注册相同的属性名，造成命名冲突。若使用组合式函数，你可以通过在解构变量时对变量进行重命名来避免相同的键名。

3. 隐式的跨 mixin 交流：多个 mixin 需要依赖共享的属性名来进行相互作用，这使得它们隐性地耦合在一起。而一个组合式函数的返回值可以作为另一个组合式函数的参数被传入，像普通函数那样。

## vue3中不推荐使用mixin的原因

通过组合式 API 解决了 mixins 的所有缺陷。

# 父子组件传参

## vuex

## prop emit

# vue3的区别

## 操作真实的dom节点获取组件实例 

### vue2 通过 ref 和this.$refs.xxx
1、使用this.$refs如果要在mouend()中使用，必须要在this.$nextTick(()=>{  } )   这里面实现，要不是找不到ref，原因是mouned（）之后，BOM节点还没有完全挂载上，于是找不到定义的ref。

2、可以直接在updata()的生命周期函数中使用，不用写this.$nextTick(()=>{  } ) 


3、在methods:{  } 方法中使用，也需要使用this.$nextTick(()=>{  } ) 等到页面完全渲染完毕之后在调用即可

### vue3 通过 ref 和 同名的const xxx=ref()