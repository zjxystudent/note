标准内置对象：string ， RegExp,Array
# object
## js对象数组会**自动按照键排序**
Chrome浏览器下创建的js对象数组会**自动按照键排序**、FireFox99.0版本（最新版本）会，FireFox 4.0.1不会。

# Array
## 遍历
<https://juejin.cn/post/7196668320077250616>
不改变原数组
- every()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。

- filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。

### Array.prototype.forEach()
对数组的每个元素执行一次给定的函数。
对数组每一项都运行传入的函数，没有返回值。
```js
// 箭头函数
forEach((element) => { /* … */ })
forEach((element, index) => { /* … */ })
forEach((element, index, array) => { /* … */ })

// 回调函数
forEach(callbackFn)
forEach(callbackFn, thisArg)

// 内联回调函数
forEach(function(element) { /* … */ })
forEach(function(element, index) { /* … */ })
forEach(function(element, index, array){ /* … */ })
forEach(function(element, index, array) { /* … */ }, thisArg)

```

###

- map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。
 - map(Number):将值以数组的格式返回

- some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。

### for in
获取属性(对象获取属性，数组找不到属性，返回下标)
### for of
获取值
## 元素操作
### 排序 Array.prototype.sort()
对原数据进行原地算法进行排序

### 返回符合条件的第一个元素的索引 Array.prototype.findIndex()

返回数组中满足提供的测试函数的**第一个元素的索引**。若没有找到对应元素则返回 -1。
```js
// 箭头函数
findIndex((element) => { /* … */ } )
findIndex((element, index) => { /* … */ } )
findIndex((element, index, array) => { /* … */ } )

// 回调函数
findIndex(callbackFn)
findIndex(callbackFn, thisArg)//thisArg  可选。执行callback时作为this对象的值。

// 内联回调函数
findIndex(function(element) { /* … */ })
findIndex(function(element, index) { /* … */ })
findIndex(function(element, index, array){ /* … */ })
findIndex(function(element, index, array) { /* … */ }, thisArg)

```
### 返回符合条件的第一个元素的值 Array.prototype.find()

返回数组中满足提供的测试函数的**第一个元素的值**。否则返回 undefined

# date
`Date` 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。使用这种存储格式，Date 类型可以精确表示 1970 年 1 月 1 日之前及之后 285 616 年的日期。

## 创建对象 Date()

要创建日期对象，就使用 new 操作符来调用 Date 构造函数：
```js
let now = new Date(); 
```
Date 构造函数的参数为空时，创建的对象将保存当前日期和时间。要基于其他日期和时
间创建日期对象，必须传入其毫秒表示（UNIX 纪元 1970 年 1 月 1 日午夜之后的毫秒数）。

ECMAScript为此提供了两个辅助方法：`Date.parse()`和 `Date.UTC()`。

## 返回日期的毫秒表示 

Date.parse()

`Date.parse()`接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。ECMA-262 第 5 版定义了 Date.parse()应该支持的日期格式，填充了第 3 版遗留的空白。所有实现都必须支持下列日期格式：

- “月/日/年”，如"5/23/2019"；
- “月名 日, 年”，如"May 23, 2019"；
- “周几 月名 日 年 时:分:秒 时区”，如"Tue May 23 2019 00:00:00 GMT-0700"；
-  ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00（只适用于
兼容 ES5 的实现）。

比如，要创建一个表示“2019 年 5 月 23 日”的日期对象，可以使用以下代码：
```js
let someDate = new Date(Date.parse("May 23, 2019")); 
```
如果传给 Date.parse()的字符串并不表示日期，则该方法会返回 NaN。如果直接把表示日期的字
符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。

换句话说，下面这行代码跟前面那行代码是等价的：`let someDate = new Date("May 23, 2019")`; 

这两行代码得到的日期对象相同。

>注意 不同的浏览器对 Date 类型的实现有很多问题。比如，很多浏览器会选择用当前日期替代越界的日期，因此有些浏览器会将"January 32, 2019"解释为"February 1, 2019"。Opera 则会插入当前月的当前日，返回"January 当前日, 2019"。就是说，如果是在 9 月 21 日运行代码，会返回"January 21, 2019"。

`Date.UTC()`也返回日期的毫秒表示，但使用的是跟 Date.parse()不同的信息来生成这个值。
传给 Date.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。

下面是使用 Date.UTC()的两个例子：
```js
// GMT 时间 2000 年 1 月 1 日零点
let y2k = new Date(Date.UTC(2000, 0)); 
// GMT 时间 2005 年 5 月 5 日下午 5 点 55 分 55 秒
let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55)); 
```
这个例子创建了两个日期 。

第一个日期是 2000 年 1 月 1 日零点（GMT），2000 代表年，0 代表月
（1 月）。因为没有其他参数（日取 1，其他取 0），所以结果就是该月第 1 天零点。

第二个日期表示 2005
年 5 月 5 日下午 5 点 55 分 55 秒（GMT）。虽然日期里面涉及的都是 5，但月数必须用 4，因为月数是零
起点的。小时也必须是 17，因为这里采用的是 24 小时制，即取值范围是 0~23。其他参数就都很直观了。

与 Date.parse()一样，Date.UTC()也会被 Date 构造函数隐式调用，但有一个区别：这种情况
下创建的是本地日期，不是 GMT 日期。

不过 Date 构造函数跟 Date.UTC()接收的参数是一样的。因此，如果第一个参数是数值，则构造函数假设它是日期中的年，第二个参数就是月，以此类推。前面的
例子也可以这样来写：
```js
// 本地时间 2000 年 1 月 1 日零点
let y2k = new Date(2000, 0); 
// 本地时间 2005 年 5 月 5 日下午 5 点 55 分 55 秒
let allFives = new Date(2005, 4, 5, 17, 55, 55); 
```
以上代码创建了与前面例子中相同的两个日期，但这次的两个日期是（由于系统设置决定的）本地
时区的日期。
ECMAScript 还提供了 Date.now()方法，返回表示方法执行时日期和时间的毫秒数。这个方法可
以方便地用在代码分析中：
// 起始时间
let start = Date.now(); 
// 调用函数
doSomething(); 
// 结束时间
let stop = Date.now(), 
result = stop - start;

> ## 月份加一
> ```js
> console.log(+new Date(2000,1,1))
>//949334400000 时间戳转 2000，2，1
>```

# Set

## 方法

### forEach

在调用forEach 遍历Set集合时，如果一个值已经被访问过了，但改制被删除并重新添加到集合，如果此次遍历没有结束，该值会被重新访问。

# Map

Map保存键值对，并记住key的原始插入顺序

## Map和Object的区别

### key

- Object中的key必须是**原始**数据类型。它们可以是字符串，数字，符号，甚至是bigInt。即使您添加非原始key（例如Object或Array），它们也将被转换为String。但是，您仍然可以检索它们。

- 使用Map，您可以将任何**数据类型**（例如Object，Array等）用作key,其内部使用SameValueZero比较操作，等同与使用严格对象相等的标准来检测键的匹配性。
   
**SameValueZero 比较也可能导致意想不到的冲突：**
   
  ```javascript
const m = new Map(); 
const a = 0/"", // NaN 
	  b = 0/"", // NaN 
	  pz = +0,
	  nz = -0; 
	  alert(a === b); // false 
	  alert(pz === nz); // true 
	  m.set(a, "foo"); 
	  m.set(pz, "bar"); 
	  alert(m.get(b)); // foo 
	  alert(m.get(nz)); // bar
```

- 即使你能添加一个Object作为在一个key的**Object**，你只能做一次。如果将多个key添加为Object，则仅保留最后一个。但是对于**Map**，情况并非如此。

***SameValueZero** 是 ECMAScript 规范新增的相等性比较算法。关于 ECMAScript 的相 等性比较，ECMAScript 规范内部定义，语言中不能使用可以，参考 MDN 文档中的文章“Equality Comparisons and Sameness”。*

### Method

-   对于Object，可以使用此表示法设置和获取值`obj[number]`，但对于Map，我们应使用的方法`get(), set(), has()`等。您可以在[MDN文档中](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FMap)阅读有关这些方法的更多信息。

- Map实例会维护键值对的插入顺序，可以 执行迭代操作

## 基本API

### 构造函数

```javascript
//空映射
const m=new Map();

//传入可迭代对象（包含键值对数组）初始化
const m1=new Map([
["key1","val1"],
["key2","val2"],
["key3","val3"],
])

// 映射期待的键/值对，无论是否提供 
const m3 = new Map([[]]);
alert(m3.has(undefined)); // true 
alert(m3.get(undefined)); // undefined
```

## WeakMap

WeakMap 是 Map 的“兄弟”类型，其 API 也是 Map 的子集。其中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。

WeakMap对key是弱引用，不影响垃圾回收的工作。一旦key被垃圾回收器回收，那么对应的键和值就访问不到了。所以WeakMap经常用于存储那些只有当key所引用的对象存在时（没有被回收）才有价值的信息。 ^354e2c

### 差异

-   **它们只能包含作为Object的key**

原始数据类型不允许作为key。如果您使用原始值，则会引发错误`TypeError: Invalid value used as weak map key`。之所以只允许Object作为key是因为从不对原始值进行垃圾回收。如果确实允许使用原始值作为key，那么您根本不会从WeakMap中受益。

-   **您需要知道key才能获得其价值**

由于引用Weak，因此WeakMap不包含可迭代项或获取key列表的方法。此外，您也无法访问WeakMap的大小。由于这些属性，WeakMap有时被称为黑匣子。

### 实例

#### 在Chrome中Map和WeakMap内存消耗情况

```javascript
function Obj(){
    this.val = new Array(10000000).join(",,,");
}

window.obj = new Obj();
let map = new Map();
map.set(window.obj, 1);
//Take a memory snapshot here

// Run the following code after the initial memory snapshot
delete window.obj
1234
//1234 is needed to avoid logging the obj in console
```
![[Chrome中Map内存消耗情况图.svg]]

***解释** 如您在上面的示例中看到的，即使在运行`delete window.obj`该变量之后，也尚未对其进行垃圾回收。这是因为即使在`obj`中删除了`window`对的引用，也没有删除Map中的引用。垃圾回收器无法释放内存，`obj`因为Map中仍然存在引用。要在Map中删除参考，您必须使用`map.clear()`或删除key`map.delete(window.obj)`。这将导致垃圾回收器释放内存。*

```javascript
function Obj(){
    this.val = new Array(10000000).join(",,,");
}

window.obj = new Obj();
let map = new WeakMap();
map.set(window.obj, 1);
//Take a memory snapshot here

// Run the following code after the initial memory snapshot
delete window.obj
1234
//1234 is needed to avoid logging the obj in console
```

![[Chrome中WeakMap内存消耗情况图.svg]]
***解释** 与Map示例相反，只要您运行`delete window.obj`，该变量就会被垃圾回收。当在`obj`中删除对的引用时`window`，垃圾回收器未找到`obj`对它的其他引用，因此释放了分配给它的内存。即使我们确实有一个WeakMap引用了`obj`，垃圾回收器仍然最终释放了内存。这是因为如前所述，WeakMap中的引用是“**Weak**”的。*

#### 添加其他数据

WeakMap允许您将其他数据添加到属于另一个或第三方代码的Object中。使用WeakMap的特殊“Weak”链接功能，我们可以确保与该外来Object关联的数据仅在该Object处于活动状态时才存在。

```javascript
weakMap.set(alienObject, "newly found secret about aliens");
// if the alienObject dies, newly found secret about aliens will also be destroyed automatically
```

#### 缓存数据

使用WeakMap，您可以将先前计算的结果与Object相关联，而不必担心内存管理。以下示例将计算结果缓存在`cache`WeakMap中。一旦将Object从引用中删除，则内存也将被释放。

```javascript
// 📁 cache.js
let cache = new WeakMap();
// compute and remember the result
function compute(obj) {
  if (!cache.has(obj)) {
    let result = obj.name + " is " + obj.age + " years old.";
    cache.set(obj, result);
    return [result,'computed'];
  }
return [cache.get(obj),'cached'];
}
// 📁 main.js
let obj = {name:'John',age:16};
let result1 = compute(obj);
let result2 = compute(obj);
console.log(result1);
//["John is 16 years old.", "computed"]
console.log(result2);
//["John is 16 years old.", "cached"]
delete obj;
//Memory is cleared as soon as obj reference is removed
```

# String

## 清除字符串两端的空格 String.prototype.trim()
`trim()` 方法从字符串的两端清除空格，**返回一个新的字符串**，而不修改原始字符串。此上下文中的空格是指所有的空白字符（空格、tab、不换行空格等）以及所有行终止符字符（如 LF、CR 等）。

# Symbol

表示**独一无二**的值，属于JavaScript的原生数据类型之一，其他数据类型是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、大整数（BigInt）、对象（Object）。

Symbol 值通过`Symbol()`函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。

## 实例

### 消除魔术字符串

魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。

```javascript
function getArea(shape, options) {
  let area = 0;

  switch (shape) {
    case 'Triangle': // 魔术字符串
      area = .5 * options.width * options.height;
      break;
    /* ... more code ... */
  }

  return area;
}

getArea('Triangle', { width: 100, height: 100 }); // 魔术字符串
```

上面代码中，字符串`Triangle`就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。

常用的消除魔术字符串的方法，就是把它写成一个变量。

```javascript
const shapeType = {
  triangle: 'Triangle'
};

function getArea(shape, options) {
  let area = 0;
  switch (shape) {
    case shapeType.triangle:
      area = .5 * options.width * options.height;
      break;
  }
  return area;
}

getArea(shapeType.triangle, { width: 100, height: 100 });
```

上面代码中，我们把`Triangle`写成`shapeType`对象的`triangle`属性，这样就消除了强耦合。

如果仔细分析，可以发现`shapeType.triangle`等于哪个值并不重要，只要确保不会跟其他`shapeType`属性的值冲突即可。因此，这里就很适合改用 Symbol 值。

```javascript
const shapeType = {
  triangle: Symbol()
};
```

上面代码中，除了将`shapeType.triangle`的值设为一个 Symbol，其他地方都不用修改。

***在typescript中可以用enum实现***

```ts
enum Role{
  ADMIN,
  VISITER,
  EMPLOYEE
}
```

### 模块的 Singleton 模式

Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。

对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？

很容易想到，可以把实例放到顶层对象`global`。

```javascript
// mod.js
function A() {
  this.foo = 'hello';
}

if (!global._foo) {
  global._foo = new A();
}

module.exports = global._foo;
```

然后，加载上面的`mod.js`。

```javascript
const a = require('./mod.js');
console.log(a.foo);
```

上面代码中，变量`a`任何时候加载的都是`A`的同一个实例。

但是，这里有一个问题，全局变量`global._foo`是可写的，任何文件都可以修改。

```javascript
global._foo = { foo: 'world' };

const a = require('./mod.js');
console.log(a.foo);
```

上面的代码，会使得加载`mod.js`的脚本都失真。

为了防止这种情况出现，我们就可以使用 Symbol。

```javascript
// mod.js
const FOO_KEY = Symbol.for('foo');

function A() {
  this.foo = 'hello';
}

if (!global[FOO_KEY]) {
  global[FOO_KEY] = new A();
}

module.exports = global[FOO_KEY];
```

上面代码中，可以保证`global[FOO_KEY]`不会被无意间覆盖，但还是可以被改写。

```javascript
global[Symbol.for('foo')] = { foo: 'world' };

const a = require('./mod.js');
```

如果键名使用`Symbol`方法生成，那么外部将无法引用这个值，当然也就无法改写。

```javascript
// mod.js
const FOO_KEY = Symbol('foo');

// 后面代码相同 ……
```

上面代码将导致其他脚本都无法引用`FOO_KEY`。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的`FOO_KEY`都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。

# RegExp
```js
var re = new RegExp("\\w+","i");
var re = /\w+/i;
```

## RegExp.prototype.test()

`test()` 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 `true` 或 `false`
```js
let str = 'hello world!';
let result = /^hello/.test(str);
console.log(result);
// true
```


# 方法 Function

## 方法

### Function.prototype.call()

call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。

> 💡 调用指定的函数，函数内的this使用指定的this

```js
function Product(name, price) {
  this.name = name;
  this.price = price;
}

function Food(name, price) {
  Product.call(this, name, price);
  this.category = 'food';
}
const test1=new Food('cheese', 5)
console.log(test1.name);
console.log(test1.price);
console.log(test1.category);
/* 
Expected output: "cheese"
Expected output: "5"
Expected output: "food" 
*/

 ```

# Json
**JSON** 是一种语法，用来序列化对象、数组、数值、字符串、布尔值和 `null` 。
## json.parse()
string->json
```js
JSON.parse(text[, reviver])
// reviver 可选,转换器，如果传入该参数 (函数)，可以用来修改解析生成的原始值，调用时机在 parse 函数返回之前。
```
>若传入的字符串不符合 JSON 规范(如:undefined,"")，则会抛出 SyntaxError 异常。

# Promise

1. [JSON](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON)