**难度:** <kbd style="color:green">简单</kbd>

给你一个字符串  `sequence` ，如果字符串 `word`  连续重复  `k`  次形成的字符串是  `sequence`  的一个子字符串，那么单词  `word` 的 **重复值为`k`**。单词 word  的 **最大重复值**  是单词` word`  在  `sequence`  中最大的重复值。如果  `word`  不是  `sequence`  的子串，那么重复值  k  为 0 。
给你一个字符串 `sequence`  和` word `，请你返回 **最大重复值  `k `**。

**示例 1：**

` "输入：sequence = \"ababc\", word = \"ab\" "输出：2 "解释：\"abab\" 是 \"ababc\" 的子字符串。 "`

**示例 2：**

"` "输入：sequence = \"ababc\", word = \"ba\" "输出：1 "解释：\"ba\" 是 \"ababc\" 的子字符串，但 \"baba\" 不是 \"ababc\" 的子字符串。 "`
"
"**示例 3：**
"
"` "输入：sequence = \"ababc\", word = \"ac\" "输出：0 "解释：\"ac\" 不是 \"ababc\" 的子字符串。 " "`

"**提示：**
"
"- 1 <= sequence.length <= 100
"- 1 <= word.length <= 100
"- sequence 和  word  都只包含小写英文字母。

"> 来源：力扣（LeetCode）
"> 链接：https://leetcode.cn/problems/maximum-repeating-substring
"> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

"## 通过内置函数解决

"执行用时：_52ms_ 内存消耗：_14.9MB_
"
"时间复杂度：_O(n)_ 空间复杂度：_O(1)_

"python 的 string 类
"
"- `count()` 方法能统计字串出现的次数，
"- `find()` 检测字串是否包含在字符串中
" 通过以上两个内置函数
"
"1. 通过 `count()` 计算 `word` 在 `sequence` 中出现的次数 `k`
"2. 依据 `find()` 判断 `sequence` 中是否存在 `k` 个 `word` 组成的字串
"3. 存在返回 `k` ,否则` k--` ,再继续 步骤 2

]
},

"class Solution:
" def maxRepeating(self, sequence: str, word: str) -> int:
" k=sequence.count(word)
" while k:
" if sequence.find(k\*word)!=-1:
" break
" k=k-1
" return k
"
"def new_func(Solution):
" result=Solution()
" print(result.maxRepeating( sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" ,word=\"aaaba\"))#5
"
"new_func(Solution)

"## 贪心+内置函数"

"执行用时：_36ms_ 内存消耗：_15MB_
"1. 令最大重复值 `k` 最大，`k=len(sequence)//len(word)`
"2. 依据 `find()` 判断 `sequence` 中是否存在 `k` 个 `word` 组成的字串
"3. 存在返回 `k` ,否则` k--` ,再继续 步骤 2



"class Solution:
" def maxRepeating(self, sequence: str, word: str) -> int:
" k=len(sequence)//len(word)
" while k:
" if sequence.find(k\*word)!=-1:
" break
" k=k-1
" return k
"result=Solution()
"print(result.maxRepeating( sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" ,word=\"aaaba\"))#5"
